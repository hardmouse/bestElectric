import { Item, ItemOptions } from '../Item';
export interface ModelAttributes {
    thumbnailSrc: string;
    enlargedSrc?: string;
    enlargedWidth?: number;
    enlargedHeight?: number;
    title?: string;
    link?: string;
    linkTarget?: string;
    color?: string;
}
export interface GalleryOptions extends ItemOptions {
    rowsPerPage?: number;
    minRowsAtStart?: number;
    infiniteScrollOffset?: number;
    photoSwipeOptions?: PhotoSwipeOptions;
}
export interface PhotoSwipeOptions {
    getThumbBoundsFn?: (index?: number) => void;
    showHideOpacity?: boolean;
    showAnimationDuration?: number;
    hideAnimationDuration?: number;
    bgOpacity?: number;
    spacing?: number;
    allowPanToNext?: boolean;
    maxSpreadZoom?: number;
    getDoubleTapZoom?: (isMouseClick?: boolean, item?: any) => number;
    pinchToClose?: boolean;
    closeOnScroll?: boolean;
    closeOnVerticalDrag?: boolean;
    mouseUsed?: boolean;
    escKey?: boolean;
    arrowKeys?: boolean;
    history?: boolean;
    galleryUID?: number;
    galleryPIDs?: boolean;
    errorMsg?: string;
    preload?: [number, number];
    mainClass?: string;
    getNumItemsFn?: () => number;
    focus?: boolean;
    modal?: boolean;
    verticalDragRange?: number;
    mainScrollEndFriction?: number;
    panEndFriction?: number;
    isClickableElement?: (el) => boolean;
    scaleMode?: string;
}
export interface InnerPhotoSwipeOptions extends PhotoSwipeOptions {
    index: number;
    loop: boolean;
}
export interface PhotoswipeItem {
    src: string;
    w: number;
    h: number;
    title: string;
}
export declare abstract class AbstractGallery<Model extends ModelAttributes = any> {
    protected elementRef: HTMLElement;
    protected userOptions: GalleryOptions;
    protected photoswipeElementRef: HTMLElement;
    protected scrollElementRef: HTMLElement;
    /**
     * Default options
     * @private
     */
    protected defaultOptions: GalleryOptions;
    protected photoswipeDefaultOptions: PhotoSwipeOptions;
    /**
     * Final gallery options after having defaulted user given options
     */
    protected options: GalleryOptions;
    /**
     * Used to test the scroll direction
     * Avoid to load more images when scrolling up
     */
    private old_scroll_top;
    /**
     * Images wrapper container
     */
    protected bodyElementRef: HTMLElement;
    /**
     * Complete collection of images
     * @type {Array}
     */
    protected _collection: Item<Model>[];
    /**
     * Partial set of items that represent the visible items
     * @type {Item[]}
     * @private
     */
    protected _visibleCollection: Item<Model>[];
    /**
     * Photoswipe images container
     * @type {Array}
     */
    private photoswipeCollection;
    /**
     * Reference to next button element
     */
    private nextButton;
    /**
     * Items for which container has been added to dom, but image has not been queries yet
     */
    protected scrollBufferedItems: any[];
    /**
     * Debounced function that queries for images after a little moment where no other images container have been added to DOM
     */
    protected flushBufferedItems: () => void;
    protected requiredItems: number;
    /**
     *
     * @param elementRef
     * @param photoswipeElementRef
     * @param userOptions
     * @param scrollElementRef
     */
    constructor(elementRef: HTMLElement, userOptions: GalleryOptions, photoswipeElementRef: HTMLElement, scrollElementRef?: HTMLElement);
    protected abstract getEstimatedItemsPerRow(): number;
    protected abstract organizeItems(items: Item[], fromRow?: number, toRow?: number): void;
    protected abstract onScroll(): void;
    protected abstract onPageAdd(): void;
    protected init(): void;
    /**
     * Return number of rows to show per page to fill the empty space until the bottom of the screen
     * Should grant all the space is used or more, but not less.
     * @returns {number}
     */
    protected abstract getEstimatedRowsPerPage(): number;
    protected defaultsOptions(): void;
    /**
     * Fire pagination event
     * Information provided in the event allows to retrieve items from the server using given data :
     * "offset" and "limit" that have the same semantic that respective attributes in mySQL.
     *
     * The gallery asks for items it needs, including some buffer items that are not displayed when given but are available to be added
     * immediately to DOM when user scrolls.
     *
     */
    protected requestItems(): void;
    /**
     * Returns option.rowsPerPage is specified.
     * If not returns the estimated number of rows to fill the rest of the vertical space in the screen
     * @returns {number}
     */
    protected getRowsPerPage(): number;
    /**
     * Add given item to DOM and to visibleCollection
     * @param {Item} item
     * @param destination
     */
    protected addItemToDOM(item: Item<Model>, destination?: HTMLElement): void;
    protected render(): void;
    protected updateNextButtonVisibility(): void;
    /**
     * Add items to collection
     * Transform given list of models into inner Items
     * @param models
     */
    addItems(models: Model[]): void;
    /**
     * Combine options from gallery with attributes required to generate a figure
     * @returns {ItemOptions}
     */
    private getItemOptions();
    protected extendToFreeViewport(): number;
    /**
     * Space between the top of the gallery wrapper (parent of gallery root elementRef) and the bottom of the window
     */
    protected getGalleryVisibleHeight(): number;
    protected startResize(): void;
    protected endResize(): void;
    /**
     * Listen to scroll event and manages rows additions for lazy load
     * @param {HTMLElement | Document} element
     */
    private bindScroll(element);
    protected openPhotoSwipe(item: Item): void;
    /**
     * Format an Item into a PhotoswipeItem that has different attributes
     * @param item
     * @returns {PhotoswipeItem}
     */
    protected getPhotoswipeItem(item: any): PhotoswipeItem;
    protected dispatchEvent(name: string, data: any): void;
    /**
     * Select all items visible in the DOM
     * Ignores buffered items
     */
    selectVisibleItems(): Model[];
    /**
     * Unselect all selected elements
     */
    unselectAllItems(): void;
    /**
     * Allows to use the same approach and method name to listen as gallery events on DOM or on javascript gallery object
     *
     * Gallery requests items when it's instantiated. But user may subscribe after creation, so we need to request again if
     * user subscribes by this function.
     *
     * @param name
     * @param callback
     */
    addEventListener(name: string, callback: (ev) => void): void;
    /**
     * Effectively empty gallery, and should prepare container to receive new items
     */
    protected empty(): void;
    /**
     * Public api for empty function
     * Emits a pagination event
     */
    clear(): void;
    /**
     * Override current collection
     * @param {Item[]} items
     */
    setItems(items: Model[]): void;
    readonly collection: Item<Model>[];
    readonly visibleCollection: Item<Model>[];
    readonly selectedItems: Model[];
    readonly width: number;
    readonly collectionLength: number;
    readonly visibleCollectionLength: number;
}
